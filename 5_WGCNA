###########################################################################################################################
# 5. Weighted Gene Co-Expression Network Analysis
###########################################################################################################################

## Navigate into the directory your gene count matrix is in
#cd $COUNTDIR
#module load r
#R

## Or download your gene count matrix file onto your local computer and read it in as a csv file 
# adjust the working directory in the read.csv line to include the path to your locally downloaded file
#install.packages("BiocManager") 
#BiocManager::install("WGCNA") 

### Load the library containing the required packages for EdgeR & WGCNA
library(WGCNA)
library(flashClust)
enableWGCNAThreads()
library('edgeR')
options(stringsAsFactors = FALSE)

### Read in the csv file containing your gene count matrix
# Fill in $LIST with the "groupings" information or the factors your are comparing expression against
Devil_Data<-read.csv("gene_count_matrix.csv",row.names=1)
DGE_Object<-DGEList(counts=Devil_Data)

# Use this to check to make sure that your sample information is correct and that your library sizes were included
# Then we filtered out genes not expressed in any individuals
filtered_genes<-rowSums(cpm(DGE_Object)>0) > 0
DGE_Object<-DGE_Object[filtered_genes, , keep.lib.sizes=FALSE]

### Normalize by library size for RNA composition by finding scaling factors for library sizes that minimize the log-fold changes 
# between the samples- kind of like an effective library size
# Log transformed the library-size normalzied gene expression count data converting output to cpms
# Finally Transpsoed data frame so it would be appropriate for required WGCNA input
DGE_Object<-calcNormFactors(DGE_Object)
data.frame<-cpm(DGE_Object,normalized.lib.sizes=TRUE,log=TRUE,prior.count=1)
mydata.trans<-as.data.frame(t(Devil_Data))

### Formatted the transformed data frame to include the sample ID information encompassed in our LIST variable
# Also read in our phenotypic data which was a csv file containing the grouping factors of interest, population and sex
# data for each sample 
# The csv file was formatted so that the first column contained the sample IDs and the second and third grouping factor data 
rownames(mydata.trans)<-c(LIST)
mydata.trans<-as.data.frame(mydata.trans)
pheno_data<-read.csv("Phenotype_Data.csv")
d1<-data.frame(lapply(mydata.trans,function(x) as.numeric(as.character(x))),check.names=F,row.names=rownames(mydata.trans))

#Next, we removed all the genes that have 0 gene copies
gsg<-goodSamplesGenes(d1,verbose=3)
gsg$allOK
if (!gsg$allOK)
{
if (sum(!gsg$goodGenes)>0)
printFlush(paste("Removing genes:",paste(names(d1)[!gsg$goodGenes],collapse=", ")))
mydata<-d1[gsg$goodSamples,gsg$goodGenes]
}

#Then we clustered our samples to see if there were any outliers to filter out and generate the soft threshold values
sampleTree<-hclust(dist(mydata),method="average")
powers<-c(c(1:10),seq(from=12,to=20,by=2))
sft<-pickSoftThreshold(mydata,powerVector=powers,verbose=5)

# Called the network topology analysis function and plotted the scale-free topology fit index as a function of the soft-thresholding power
pdf(file="soft_thresholding_power.pdf")
cex1=0.9
plot(sft$fitIndices[,1],-sign(sft$fitIndices[,3])*sft$fitIndices[,2],xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",main=paste("Scale independence"),ylim=c(-0.5,0.9))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],labels=powers,cex=cex1,col="red")
abline(h=0.7,col="red")
plot(sft$fitIndices[,1],sft$fitIndices[,5],xlab="Soft Threshold (power)",ylab="Mean Connectivity",type="n",main=paste("Mean connectivity"))
text(sft$fitIndices[,1],sft$fitIndices[,5],labels=powers,cex=0.9,col="red")
dev.off()

### At this point, we stopped to look at the figure to see derive the soft thresholding powe, which was the
# lowest power for which the scale-free topology fit index reaches 0.70 


